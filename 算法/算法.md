## 说明

## 目录

## 时间复杂度

### 常数时间的操作

> - 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作，**如常用的4则运算，位运算，数组取第i个元素等都是常数操作,而链表取第i个元素就需要从头挨个遍历，就与数据量相关，它就不是一个常数操作**
> - 常用O(读作big O)来表示复杂度

### 时间复杂度的计算

> 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那
> 么时间复杂度为O(f(N))。
>
> **以选择排序法为例**：
>
> ```
> 第一次循环：读取每个数，次数为n次，每个数与第一个数进行比较，次数为n，将最小值与第1个数交换，次数为1，总的次数为n+n+1
> 第二次循环：读取每个数，次数为n-1次，每个数与第2个数进行比较，次数为n-1，将最小值与第2个数交换，次数为1，总的次数为(n-1)+(n-1)+1
> ......
> 总的次数：a*n^2+b*n+c,根据规则，只保留高阶项，则选择排序法的时间复杂度为O(n^2)
> ```
>
> 

### 算法的评估

> 评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行
> 时间，也就是“常数项时间”

## 额外空间复杂度

> 即算法实现过程中需要开辟的额外空间复杂度
>
> 以选择排序为例，额外空间复杂度为O(1)，只需要2个for循环的index变量+一个最小值的索引变量（每次循环都会释放）+1个交换时的临时变量(每次循环都会释放)，

## 异或运算

### 基础

> - 符号：^
>
> - 运算规则：2个二进制位进行异或运算，相同为0，不同为1，也可以理解为**不进位的加法**
>
>   | 运算 | 结果 |
>   | ---- | ---- |
>   | 1^1  | 0    |
>   | 1^0  | 1    |
>   | 0^1  | 1    |
>   | 0^0  | 0    |
>
> - 性质：使用不进位加法解释交换律和结合律，同一个二进制位上1的个数为奇数个，则结果的该二进制位为1，否则为0
>
>   - 0 ^ N = N   ,  N ^ N = 0
>   - 满足交换律：a^b = b^a
>   - 满足结合律：a^b^c = a^(b^c)
>
> - 基于异或运算实现**2数交换**
>
>   注意：前提是a,b两个变量的内存区域不同，即不是同一个变量，**如数组的i和j两个位置进行交换，若i和j相等，就会将i位置的值变为0**
>
>   ```java
>   有两个数a,b,进行如下操作即可实现交换
>   a = a ^ b;
>   b = a ^ b;
>   a = a ^ b;
>   ```

### 面试题

#### 题目1

> 有一个数组有n种数，其中只有1种数出现奇数次，其它数都出现偶数次，找到出现奇数次的数

```java
public int findOne(int[] arr) {
    if (arr == null || arr.length == 0) {
        throw new IllegalArgumentException("array is empty!");
    }

    int result = 0;
    for (int i : arr) {
        result ^= i;
    }

    return result;
}
```

#### 题目2

> 有一个数组有n种数，其中只有2种数出现奇数次，其它数都出现偶数次，找到这2个出现奇数次的数

**思路**

> 1. 假设2个数为a和b，**a!=b,  a^b!=0**
> 2. 类似题目1，可以得到  t1 = a^b，由于a^b!=0，所以t1必定有一个二进制位不等于0，则a和b的某个二进制位不同，此时我们将数组中的数分为2类，第一类为指定二进制位为1，第二类为指定二进制位为0，这里就会把a和b分别分到2个类别去
> 3. 分类1的数进行亦或，最终的结果 t2即为a或者b
> 4. 由t1^t2即可得到另一个数