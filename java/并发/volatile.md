# CPU Cache模型

- cpu的处理速度和内存的访问速度差距很大，所以就在cpu和主存之间添加缓存

- 现在缓存一般有3级，L1(level 1 cache 分为 L1i程序指令和L1d程序数据),L2,L3，L1的速度最快，一般情况下（差不多80%）cpu可以在L1找到需要的数据,L1找不到就到L2继续找，依次类推

- 缓存的最小单位是cache line，大小64kb

- cpu缓存一致性问题

  - 总线加锁（效率较低）：只有一个cpu能获取到锁，对变量进行操作

  - 缓存一致性协议

    > 1. 读取操作，不做任何处理，只是将cache的数据读取到寄存器
    > 2. 写入操作，发出信号使其它cpu将变量的cache line置为无效状态，只能从主存重新获取最新数据

# java内存模型

- 共享变量只能存储于主存中，每个线程都可以访问
- 每个线程都有私有的工作内存或者称为本地内存
- 工作内存只存储该线程对共享变量的副本
- 线程不能直接操作主内存，只有先操作了工作内存之后才能写回主内存
- 工作内存和java内存模型只是一个抽象的概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等
- java内存模型和操作系统的内存模型很类似

# 并发编程的三大特性

- 原子性：操作要么都完成，要么都不执行，多个原子性的操作合在一起就不一定是原子性的，java保证原子性可以使用synchronized或者使用JUC包的锁，非原子性操作比如银行转账，i++，
- 可见性：当一个线程对共享变量修改后，其它线程可以立即看到修改后的值，这和操作系统使cache line失效类似，必须重新从主存获取变量的最新值
- 有序性：即程序代码执行过程中的执行顺序，java编译器会对代码进行**指令重排序**进而优化代码，但是并不会对程序的运行结果产生任何影响，然而在多线程情况下，可能就会产生问题，volatile可以禁止指令重排序

# volatile:不稳定的

- volatile只能用来修饰**类变量和实例变量**，对于方法参数、局部变量以及实例常量，类常量都不能进行修饰

- volatile保证可见性：**volatile只能保证每次执行读取操作的时候都是从主存获取最新值**，对一个变量的写操作要早于对这个变量之后的读操作，即写入操作执行后，会使其它线程的缓存失效，下一次读取操作会重新从主存读取最新数据

- volatile保证有序性：volatile可以禁止指令重排序，volatile变量之前和之后的语句还是可以重排序，但是之前的代码不管怎么重排序都只能在该变量之前执行

  > 下面的代码单线程下是完全正确的，但多线程下就不一定，由于指令重排序，init=true可能优先执行，其它线程就会获取到不可用的context,使用volatile声明init即可解决问题

  ```java
  boolean init = false;
  public Context load(){
      if(!init){
          context=loadContext();
          init=true;
      }
      return context;
  }
  ```

- volatile不保证原子性：如多个线程对变量进行修改，虽然可以保证变量的可见性，但是由于cpu的调度，会导致非预期的结果，如：多个线程对变量进行加1操作，执行1000次，执行结果一般都不是1000；

  > i++是非原子性操作，分为3步：读取i的值，进行加一操作，写回主存，volatile只能保证执行第一步的时候是会直接从主存中获取最新的值，若执行完第一步后cpu调度去执行线程2进行了加1操作，虽然会使线程1缓存行失效，但是读取操作已经完成，只有下一次才会重新读取主存的值

# JMM（java内存模型）如何保证三大特性

- JVM采用内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异
- 原子性：java中，对基本数据类型的变量读取和赋值操作都是原子性的，对引用类型的变量读取和赋值操作也是原子性的,但是y=x不是原子操作，
- 可见性：volatile，synchronized,JUC的lock
- 有序性：volatile，synchronized,JUC的lock