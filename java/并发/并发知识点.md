## 说明

## 目录

## 基础知识

### 线程与进程

> 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位,1个进程包含一个或多个线程
>
> [进程和线程的主要区别](https://blog.csdn.net/kuangsonghan/article/details/80674777)

### 线程的状态转换

[Java多线程及线程状态转换](https://www.cnblogs.com/nwnu-daizh/p/8036156.html)

### wait()和notify()

> -  两个方法只有在synchronized中才会生效，否则会抛出异常
> - wait():执行了该方法的线程释放对象的锁，JVM会把该线程放到对象的等待池中。该线程等待其它线程唤醒 
> - notify():执行该方法的线程唤醒在对象的等待池中等待的一个线程，JVM从对象的等待池中随机选择一个线程，把它转到对象的锁池中

#### 线程虚假唤醒

> - 在生产者消费者模型中，不能使用if来判断共享变量，需要放在循环中，当线程被唤醒时，再判断一次条件
>
>   ```java
>        synchronized (obj) {
>            while (<condition does not hold>)
>                obj.wait();
>            ... // Perform action appropriate to condition
>        }
>   
>   ```
>
> - 以2个生产者+2个消费者为例，目的是生产者生产1个产品，立即通知消费者消费，始终保持产品数量为0
>
>   ```java
>   class Apple {
>       private int number = 0;
>   
>       public synchronized void increment() throws InterruptedException {
>           if (number != 0) {
>               wait();
>           }
>           number++;
>           System.out.println(String.format("%s产生了一个苹果，苹果数：%d", Thread.currentThread().getName(), number));
>           notifyAll();
>       }
>   
>       public synchronized void decrement() throws InterruptedException {
>           if (number == 0) {
>               wait();
>           }
>           number--;
>           System.out.println(String.format("%s消费了一个苹果，苹果数：%d", Thread.currentThread().getName(), number));
>           notifyAll();
>       }
>   }
>   
>   
>   public class Main {
>       public static void main(String[] args) {
>           Apple apple = new Apple();
>   
>           new Thread(() -> {
>               try {
>                   for (int i = 0; i < 10; i++) {
>                       apple.increment();
>                   }
>               } catch (InterruptedException e) {
>                   e.printStackTrace();
>               }
>           }, "生产者A").start();
>           new Thread(() -> {
>               try {
>                   for (int i = 0; i < 10; i++) {
>                       apple.increment();
>                   }
>               } catch (InterruptedException e) {
>                   e.printStackTrace();
>               }
>           }, "生产者B").start();
>           new Thread(() -> {
>               try {
>                   for (int i = 0; i < 10; i++) {
>                       apple.decrement();
>                   }
>               } catch (InterruptedException e) {
>                   e.printStackTrace();
>               }
>           }, "消费者A").start();
>           new Thread(() -> {
>               try {
>                   for (int i = 0; i < 10; i++) {
>                       apple.decrement();
>                   }
>               } catch (InterruptedException e) {
>                   e.printStackTrace();
>               }
>           }, "消费者B").start();
>       }
>   }
>   ```
>
>   运行结果可能出现大于1的数甚至小于0的数
>
> - 产生以上问题的原因解读
>
>   - 首先，4个线程启动，由于number开始为0，由于使用了synchronized，同一时间只能有一个线程获取到对象锁，加入生产者A拿到锁，此时不满足number != 0，则会生产一个苹果，然后notifyAll()通知其它3个线程	
>
>     ![1583573337614](images/1583573337614.png)
>
>   - 若此时生产者B拿到锁，此时满足number != 0，进入wait状态，让出锁
>
>   - 然后生产者A又拿到锁，此时满足number != 0，进入wait状态，让出锁
>
>   - **注意**：此时生产者A、B都处于wait状态，若下次拿到锁，都会对number 就你行+1操作，就产生了预料之外的结果，若使用while来判断条件，线程被激活后，还会再判断一次number，就灭蝇问题
>
>   - 然后消费者A拿到了锁，消费一个苹果，然后notifyAll()通知其它3个线程

### synchronized

- 对象的同步方法中可以调用另一个同步方法吗？

  > 可以，一个任务（即线程）可以多次获得对象的锁，每调用一个同步方法，对象锁计数+1，退出方法-1

- 类的static方法添加synchronized，使用的锁对象是类的class对象？

  > 对，synchronized static方法可以在类的范围内防止对static数据的并发访问

### 并发底层知识

[并发机制底层实现整理](https://www.jianshu.com/p/1e82c75034b7)

### volatile

[volatile 相关整理](https://www.jianshu.com/p/ccfe24b63d87)

> - volatile保证线程每次访问到的数据都是最新的数据，即从主存中直接获取
> - volatile可以防止指令从排序
> - volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性

### Unsafe

[说说Java的Unsafe类](https://www.jianshu.com/p/cda24891f9e4)

[JAVA中神器的双刃剑--Unsafe](https://www.cnblogs.com/throwable/p/9139947.html)

### CAS

[java中的CAS实现原理](https://www.cnblogs.com/javalyy/p/8882172.html)

#### 解决CAS的ABA问题

- AtomicStampedReference和AtomicMarkableReference

  > [AtomicStampedReference使用方法](https://blog.csdn.net/qq_21993785/article/details/80667021)
  >
  > [关于AtomicStampedReference使用的坑](https://blog.csdn.net/xybz1993/article/details/79992120)
  >
  > [AtomicReference，AtomicStampedReference与AtomicMarkableReference的区别](https://www.cnblogs.com/xyhz0310/p/9627582.html)

### AQS

[Java技术之AQS详解](https://www.jianshu.com/p/da9d051dcc3d)

### java四种引用类型

[软引用、弱引用、虚引用-他们的特点及应用场景](https://www.jianshu.com/p/825cca41d962)

### java创建线程的几种方式

> - 继承Thread类
>
> - 实现接口Runnable
>
> - 实现Callable，Callable接口实现的方法为call，并且方法有返回值，方法会抛出异常
>
>   ```java
>   public class MyThread {
>   
>       public static class MyRunnable implements Runnable {
>   
>           @Override
>           public void run() {
>               System.out.println("MyRunnable start");
>           }
>       }
>   
>       public static class MyCallable implements Callable<String> {
>   
>           @Override
>           public String call() throws Exception {
>               System.out.println("MyCallable start");
>               return "MyCallable";
>           }
>       }
>   
>       public static void main(String[] args) throws ExecutionException, InterruptedException {
>           MyCallable myCallable = new MyCallable();
>           FutureTask<String> futureTask = new FutureTask<>(myCallable);
>           new Thread(futureTask).start();
>   
>           System.out.println(futureTask.get());
>       }
>   }
>   ```
>
> - 

## JUC包

### ForkJoin框架

#### 简介

> 从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。
>
> 这种思想和MapReduce很像（input --> split --> map --> reduce --> output）
>
> 主要有两步：
>
> - 第一、任务切分；
> - 第二、结果合并
>
> 它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中**偷一个任务执行（工作窃取）**，这样可以充分利用资源。
>
> [Java ForkJoin框架](https://www.cnblogs.com/cjsblog/p/9078341.html)
>
> [forkJoin全面剖析](https://www.cnblogs.com/linlinismine/p/9295701.html)

#### 使用方法

> - 继承RecursiveTask创建带有返回值的任务，没有返回值使用RecursiveAction
> - 任务内部需要有一个判断任务是否需要继续拆分的机制
> - 当任务需要拆分时，拆分后，需要使用invokeAll()递归拆分子任务
> - 使用join()方法获取任务的返回值
> - 执行主任务需要先创建一个ForkJoinPool，由ForkJoinPool的实例提交该任务,然后使用join方法即可获取任务结果

#### 简单使用

> 求2个整数之间所有整数的和

SumTask.java

```java
public class SumTask extends RecursiveTask<Long> {
    private Long start;
    private Long end;
    private final Long THRESHOLD = 1000L;

    public SumTask(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if(end-start<=THRESHOLD){
             return LongStream.range(start,end+1).sum();
        }else {
            Long mid = (start+end)/2;
            SumTask left = new SumTask(start,mid);
            SumTask right = new SumTask(mid,end);
            invokeAll(left,right);
            return left.join()+right.join();
        }
    }
}
```

ForkJoinTest.java

```java
public class ForkJoinTest {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        SumTask sumTask = new SumTask(1L, 1000000000L);
        forkJoinPool.execute(sumTask);
        System.out.println(sumTask.join());
        long end = System.currentTimeMillis();
        System.out.println("time:"+(end-start));
    }
}
```

### 使用ReentrantLock和Condition实现精准控制线程交替打印

> - 要实现3个线程交替顺序打印，可以通过还可以通过join方法实现

```java
class MyPrint {
    private int flag = 1;
    private Lock lock = new ReentrantLock();
    private Map<Integer, Condition> conditionMap = new HashMap<>();

    public MyPrint() {
        Condition c1 = lock.newCondition();
        Condition c2 = lock.newCondition();
        Condition c3 = lock.newCondition();
        conditionMap.put(1, c1);
        conditionMap.put(2, c2);
        conditionMap.put(3, c3);
    }

    public void print(int printTime) {
        lock.lock();
        try {
            while (flag != printTime) {
                conditionMap.get(flag).await();
            }
            for (int i = 0; i < printTime * 5; i++) {
                System.out.println(String.format("线程%s,111", Thread.currentThread().getName()));
            }
            int newFlag = (printTime + 1) % 4;
            flag = newFlag == 0 ? 1 : newFlag;
            conditionMap.get(flag).signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}

public class ConditionDemo {
    public static void main(String[] args) {
        MyPrint myPrint = new MyPrint();
        new Thread(() -> myPrint.print(1), "A").start();
        new Thread(() -> myPrint.print(2), "B").start();
        new Thread(() -> myPrint.print(3), "C").start();
    }
}
```

## CAS（Compare And Swap）

### 什么是原子操作

> 对于java来说。如i++这种操作，并不是原子的，i++分为3步：读取i的值、加一、写回内存；CAS是操作系统提供的可以对上诉情况进行原子操作的指令，它的原理如下：
>
> - CAS包含3个操作数
>   - 内存地址V
>   - 期望值A
>   - 新值B
>
> - 首先一个内存地址V保存了一个变量,线程从V上读取的值与期望的值A相同，则将新值B赋值给地址V，否则不作操作，返回失败

### CAS存在的问题

#### ABA问题

> 有2个线程，其中线程1预期值为A，这时线程2将原始值修改A-->B-->A，线程2修改了2次，又将值修改回了原值A，这对于线程1是无感知的，但其实内存中的值是修改了的
>
> **解决办法**：增加一个版本号，对于每一次修改都修改版本号

#### 性能问题

> 如AotimicInteger的getAndIncrement方法，对原值进行加一操作，每次调用都会内部**自旋**直到成功为止，如果自旋次数过多，就比较耗费性能

#### 只能保证一个变量的原子操作

> java提供了一个类**AtomicReference**解决这个问题，将多个变量组合成一个对象来操作

### java原子操作类分类

> - 更新基本类型类型：AtomicBoolean， Atomiclnteger, AtomicLong
> - 更新数组类:AtomiclntegerArray. AtomicLongArray， AtomicReferenceArray
> - 更新引用类型:AtomicReference， AtomicMarkableReference，AtomicStampedReference
>   - AtomicMarkableReference和AtomicStampedReference都是解决ABA问题的，AtomicMarkableReference关心的是变量是否被修改过，而AtomicStampedReference关心的是变量被修改过几次
> - 原子更新字段类:AtomicReferenceFieldUpdater,AtomiclntegerFieldUpdater,AtomicLongFieldUpdater

### java原子操作类使用

#### Atomiclnteger

```java
public class Test01 {

    public static void main(String[] args) {
        AtomicInteger ai = new AtomicInteger(0);
        ai.getAndIncrement();   //i++
        System.out.println(ai.get());
        ai.incrementAndGet();   //++i
        System.out.println(ai.get());
    }
}
```

#### AtomicReference

```java
public class Test01 {

    public static void main(String[] args) {
        User user = new User("zhangsan",18);
        AtomicReference<User> reference = new AtomicReference<>();
        reference.set(user);
        System.out.println(reference.get());
        User user2 = new User("lisi",20);
        //比较对象的引用
        reference.compareAndSet(user,user2);
        System.out.println(reference.get());

    }

    static class User{
        private String name;
        private int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return "User{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
}
```

#### AtomiclntegerArray

```java
public class Test01 {

    public static void main(String[] args) {
        int[] arr = {1, 2};
        AtomicIntegerArray ref = new AtomicIntegerArray(arr);
        //将第一个元素修改为3
        int arr0 = ref.getAndSet(0, 3);
        System.out.println(arr[0]); //1
        System.out.println(arr0);   //1
        System.out.println(ref.get(0)); //3
    }
}
```

#### AtomicStampedReference

```java
public class Test01 {

    public static void main(String[] args) {
        String str = "hello";
        AtomicStampedReference<String> ref = new AtomicStampedReference<>(str, 0);
        boolean result = ref.compareAndSet(str, "hello world", 0, 1);
        System.out.println(result); //true
        //虽然引用的值是对的，但版本号不对，则会修改失败
        boolean result2 = ref.compareAndSet(ref.getReference(), "hello world2", 0, 2);
        System.out.println(result2); //false
    }
}
```

##### 实现原理

> - 使用内部类Pair持有引用和版本号
>
> - compareAndSet源码
>
>   ```java
>   public boolean compareAndSet(V   expectedReference,
>                                V   newReference,
>                                int expectedStamp,
>                                int newStamp) {
>       Pair<V> current = pair;
>       //引用和版本号都对应才进行修改
>       //或者新的引用与版本号与当前的引用和版本号才进行修改
>       return
>           expectedReference == current.reference &&
>           expectedStamp == current.stamp &&
>           ((newReference == current.reference &&
>             newStamp == current.stamp) ||
>            casPair(current, Pair.of(newReference, newStamp)));
>   }
>   
>   private boolean casPair(Pair<V> cmp, Pair<V> val) {
>       return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
>   }
>   ```
>

### java8对CAS的优化

> 增加了LongAdder和DoubleAdder

## 显示锁

### 说明

> - 我们平时使用的synchronized是内置锁，它是java语言提供的特性，从jdk7依赖，synchronized的性能不断被优化，已经不像开始那样是重量级锁了
> - 在没有特殊要求的情况下，就可以使用synchronized进行加锁
> - 显示锁即Lock接口

### Lock接口使用场景

> - 获取锁可中断
> - 获取锁可以使用超时
> - 可以尝试获取锁
> - 读多写少的情况可以使用读写锁

### Lock接口核心方法

> - lock():加锁
> - lockInterruptibly()：加锁时可中断
> - newCondition()：获取一个与当前锁关联的Condition对象
> - tryLock()：尝试加锁
> - tryLock(long time, TimeUnit unit)：带超时的尝试加锁
> - unlock()：解锁
>
> ![1586349450473](images/1586349450473.png)

### Lock接口使用

```java
public class LockDemo {

    private static Lock lock = new ReentrantLock();

    private static int a = 1;

    public static void increment() {
        lock.lock();
        try {
            a++;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {//保证锁能够被释放
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        increment();
    }
}
```

### 可重入锁

> - 可重入锁，指的是**以线程为单位**，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的
> - synchronized 和   ReentrantLock 都是可重入锁
> - 可重入锁的意义之一在于**防止死锁**
> - 实现原理实现是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 ；如果同一个线程再次请求这个锁，计数器将递增；每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。
> - 对于synchronized修饰的同步方法，可以在同步方法中再调用同步方法，这就叫可重入，synchronized会在内部维护一个计数器，每进入一次同步方法，计数加1，退出则减一，最后恢复为0，这时其它线程就可以获取到锁
> - **一个线程执行synchronized同步代码时，再次重入该锁过程中，如果抛出异常，会释放锁**
> - ReentrantLock即是一个基于Lock接口实现的可重入锁，功能同synchronized相同，而且功能更加丰富

### 公平锁与非公平锁

#### 说明

> - 锁Lock分为公平锁和非公平锁。
> - 公平锁：表示线程获取锁的顺序是按照加锁的顺序来分配的，及先来先得，先进先出的顺序。（优于操作系统时间片的切换，也不一定按顺序，一两个线程的顺序变化了，只是这种概率很小）
> - 非公平锁：表示获取锁的抢占机制，是随机获取锁的，和公平锁不一样的就是先来的不一定能拿到锁，
>   有可能一直拿不到锁，所以结果不公平。
> - 非公平锁的效率高于公平锁：因为当线程A获取到锁时，线程B无法获取到锁，这时线程B就会被挂起，当线程A执行完后，这时有一个线程C也来获取锁，它就会先获取到锁，因为线程B从挂起状态恢复（上下文切换）需要较长的时间，可能当线程C执行完后，线程B刚好就恢复了，这样效率就提升了，减少了等待线程B恢复挂起的时间
> - `ReentrantLock`默认创建的是非公平锁，要创建公平锁，可以使用其带参数的构造方法创建

#### 举例

> 以ATM取钱为例，如图
>
> ![1586356447955](images/1586356447955.png)
>
> **公平锁**：大家都排队，如果一个线程堵着了(路人甲)，其他线程只能等待这个。最终，三个线程操作完成，总耗时9min.
>
> **非公平锁情况下**：多个线程操作的共享资源的时候，发现共享资源还没有被锁定(路人甲还在摸索过程)，就尝试插队(路人丙尝试和甲沟通，先插队操作并教会甲)，如果插队成功(甲同意了)，就操作共享资源(丙先操作ATM机)；如果插队失败(甲不同意)，接着排队(丙回到队伍中排队)。如果插队成功，最终耗时：5min.

#### 各自优缺点

> **非公平锁**
>
> - 优点：效率高；
> - 缺点：容易导致线程“饥饿”。当多个线程使用非公平的话，有可能有一个线程一直就获取不到竞争权，导致这个线程会“饥饿而死”
> - 适用场景：如果在不考虑TPS(单位时间内成功完成的次数)作为唯一考量指标的场景下，可以使用非公平锁来操作，因为非公平锁能提高系统的吞吐量
>
> **公平锁**
>
> - 优点：避免了线程的“饥饿”；
> - 缺点：性能相对于公平锁会差很多

#### 实现原理

![1586356600546](images/1586356600546.png)

### 排他锁

> 即锁只能被一个线程获取，synchronized和ReentrantLock都是排他锁

### 读写锁

> - 多个读线程可以互不影响，一旦有写线程写数据，则停止其它线程操作
>
> - 读和读互不影响，读和写互斥，写和写互斥
>
> - ReadWriteLock是读写锁接口，其实现是
>
>   ![1586352945460](images/1586352945460.png)
>
> - 其性能优于synchronized，当对于资源的操作读多写少的情况，可以使用ReadWriteLock

#### ReadWriteLock

> - Java并发库中ReetrantReadWriteLock实现了ReadWriteLock接口并添加了可重入的特性
> - ReetrantReadWriteLock读写锁的效率明显高于synchronized关键字
> - ReetrantReadWriteLock读写锁的实现中，读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的
> - ReetrantReadWriteLock读写锁的实现中，需要注意的，当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁

#### 锁升级、降级

> - 同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，ReentrantReadWriteLock是不支持的，下面代码会产生死锁
>
>   ```java
>   ReentrantReadWriteLock rtLock = new ReentrantReadWriteLock();
>   rtLock.readLock().lock();
>   System.out.println("get readLock.");
>   rtLock.writeLock().lock();
>   System.out.println("blocking");
>   ```
>
> - ReentrantReadWriteLock支持锁降级,同一个线程先获取了写锁，然后可以获取读锁，不会产生死锁，但是不释放写锁还是会产生问题，不释放的话其它线程就无法获取写锁
>
> - 多线程获取读锁不互斥，读写锁之间为互斥

### Condition

#### 概述

> - Condition实现了Lock锁的通知唤醒机制
> - 与synchronized的wait和notify对应
> - Condition接口的await与Object的wait对应
> - Condition接口的signal与Object的notify对应
> - 通知时建议使用signal而不是signalAll，保证精确唤醒

#### 使用

## AQS